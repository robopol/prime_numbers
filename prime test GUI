import tkinter as tk
from tkinter import messagebox
import sympy
import math
import multiprocessing
import gmpy2
from gmpy2 import mpz, powmod, log2, is_prime
from concurrent.futures import ProcessPoolExecutor
import random
import time
import concurrent.futures
from tkinter import ttk

# List of known exponents p for Mersenne primes (M_p = 2^p - 1)
# Source: https://www.mersenne.org/primes/ (GIMPS) - as of October 2024
KNOWN_MERSENNE_EXPONENTS = {
    2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 2203, 2281, 3217, 4253, 4423,
    9689, 9941, 11213, 19937, 21701, 23209, 44497, 86243, 110503, 132049, 216091, 756839,
    859433, 1257787, 1398269, 2976221, 3021377, 6972593, 13466917, 20996011, 24036583,
    25964951, 30402457, 32582657, 37156667, 42643801, 43112609, 57885161, 74207281,
    77232917, 82589933, 136279841
}

PROGRESS_BAR_MAX = 100 # Define a global variable for the progress bar maximum

# Helper function to update the result_text_area (defined later, but declared here for clarity if needed or move definition up)
# This will be defined near the GUI section later.
# def update_result_text(new_text): pass 

# -------------------  LOGIC  -------------------

# New function to check for a direct text expression of a Mersenne prime
def check_direct_mersenne_expression(input_str_raw, start_time_check, root_widget, progress_bar_widget):
    cleaned_input_str = input_str_raw.replace(" ", "").lower() # Remove spaces and convert to lowercase
    P_EXPONENT_THRESHOLD_FOR_DISPLAY = 127 # Threshold for p above which we don't print the full M_p value

    for p_exponent in KNOWN_MERSENNE_EXPONENTS:
        expected_forms = [
            f"2**{p_exponent}-1",
            f"pow(2,{p_exponent})-1"
        ]
        if cleaned_input_str in expected_forms:
            end_time_check = time.time()
            if p_exponent > P_EXPONENT_THRESHOLD_FOR_DISPLAY:
                result_text_direct = f"Input expression '{input_str_raw}' corresponds to M_{p_exponent}.\nThis is a known Mersenne Prime."
            else:
                try:
                    mersenne_value_mpz = mpz(2)**p_exponent - 1
                    result_text_direct = f"Input expression '{input_str_raw}' corresponds to M_{p_exponent} = {mersenne_value_mpz}.\nThis is a known Mersenne Prime."
                except OverflowError:
                    result_text_direct = f"Input expression '{input_str_raw}' corresponds to M_{p_exponent}.\nThis is a known Mersenne Prime (value calculation issue)."
            
            update_result_text(f"{result_text_direct}\n(Verified by direct expression match in {end_time_check - start_time_check:.4f} seconds)") # MODIFIED: Use helper
            if progress_bar_widget:
                progress_bar_widget['value'] = PROGRESS_BAR_MAX
            root_widget.update_idletasks()
            return True
    return False

big_num = 10**20
basic_field = [2, 3, 5, 7, 11, 13]
big_num2 = 10**12

def check_known_mersenne_primes(n_mpz, start_time_check, root_widget, progress_bar_widget):
    """
    Checks if the given number n_mpz is a known Mersenne prime
    by direct comparison with M_p = 2^p - 1 for known exponents p.
    If yes, updates the GUI and returns True. Otherwise returns False.
    n_mpz is expected to be gmpy2.mpz.
    root_widget is the main window for update_idletasks.
    progress_bar_widget is the progress bar widget.
    """
    if n_mpz <= 7: 
        return False

    for p_exponent in KNOWN_MERSENNE_EXPONENTS: 
        try:
            power_of_2 = mpz(2)**p_exponent
            mersenne_candidate = power_of_2 - 1
        except OverflowError: 
            continue 

        if n_mpz == mersenne_candidate:
            end_time_check = time.time()
            update_result_text(f"{n_mpz} is a known Mersenne Prime (M{p_exponent}).\n(Verified in {end_time_check - start_time_check:.4f} seconds)") # MODIFIED: Use helper
            if progress_bar_widget: 
                progress_bar_widget['value'] = PROGRESS_BAR_MAX
            root_widget.update_idletasks()
            return True
    return False

def classical_filter(n):
    """
    A simple filtering function: checks divisibility by the small primes
    in basic_field and looks for divisors of the form 6kÂ±1 up to sqrt(big_num2).
    If a divisor is found, returns a string indicating the divisor.
    Otherwise, returns None.
    """
    for divisor in basic_field:
        if n % divisor == 0 and n != divisor:
            return f"Number is composite, divisible by {divisor}"
    k = 1
    end = round(math.sqrt(big_num2)) + 1
    while True:
        divisor1 = 6 * k - 1
        divisor2 = 6 * k + 1
        if divisor1 > end:
            break
        if n % divisor1 == 0 and n != divisor1:
            return f"Number is composite, divisible by {divisor1}"
        if n % divisor2 == 0 and n != divisor2:
            return f"Number is composite, divisible by {divisor2}"
        k += 1
    return None

def euler_test_single_base(args):
    """
    Performs an Euler-based primality test for a given number n and base a.
    Checks if a^((n-1)/2) % n is 1 or n-1 (Euler's criterion).
    Returns (base, True) if the condition holds, (base, False) otherwise.
    n_mpz and a_mpz are expected to be gmpy2.mpz objects.
    """
    n_mpz, a_mpz = args

    # Euler's criterion applies to odd n. n=2 is prime and handled earlier.
    # Base a must be > 1 and < n, and gcd(a,n) must be 1.
    if n_mpz <= 2 or n_mpz % 2 == 0:
        return (int(a_mpz), False) 
    if not (1 < a_mpz < n_mpz):
        return (int(a_mpz), False) 
    if gmpy2.gcd(a_mpz, n_mpz) != 1:
        return (int(a_mpz), False) # n is composite if a shares a factor (and a < n)

    exponent = (n_mpz - 1) // 2
    try:
        x = powmod(a_mpz, exponent, n_mpz)
    except ValueError: # Should be very rare given the checks above
        return (int(a_mpz), False)

    # Check if x is 1 or n-1 (which is congruent to -1 mod n_mpz)
    if x == 1 or x == (n_mpz - 1):
        return (int(a_mpz), True)
    else:
        return (int(a_mpz), False)

def run_euler_tests_parallel(n_mpz, bases_int_list, progress_bar_widget, root_widget, start_percentage):
    """
    Runs the Euler-based primality test in parallel for multiple bases.
    n_mpz: The number to test (gmpy2.mpz).
    bases_int_list: A list of integer bases to test.
    Updates a progress bar during execution.
    Returns a list of (base, pass/fail) tuples.
    """
    # Prepare arguments for the pool, ensuring bases are valid for the test with n_mpz
    args_for_pool = []
    for b_int in bases_int_list:
        if 1 < b_int < n_mpz: # Base must be > 1 and < n
            # Further check: gcd(b_int, n_mpz) == 1 for Euler's criterion
            # This is handled inside euler_test_single_base now, so we can pass it.
            args_for_pool.append((n_mpz, mpz(b_int)))
    
    results_from_pool = []
    if not args_for_pool: 
        # This can happen if n_mpz is very small (e.g., 3) and all default_bases are >= n_mpz
        # Or if the user_provided base is also unsuitable.
        # The check_prime function should handle very small n before calling this.
        return results_from_pool 
        
    num_bases = len(args_for_pool)
    bases_processed = 0
    progress_range = PROGRESS_BAR_MAX - start_percentage

    with ProcessPoolExecutor(max_workers=multiprocessing.cpu_count()) as executor:
        future_to_base_arg = {executor.submit(euler_test_single_base, arg_pair): arg_pair for arg_pair in args_for_pool}
        
        for future in concurrent.futures.as_completed(future_to_base_arg):
            original_arg_pair = future_to_base_arg[future]
            # base_tested_mpz = original_arg_pair[1] # This is the mpz version of the base
            try:
                result_tuple = future.result() # (int_base, bool_passed)
                results_from_pool.append(result_tuple) 
            except Exception as exc:
                # print(f"Error in Euler test worker for base {int(base_tested_mpz)}: {exc}")
                # If a worker process dies or has an unhandled error, record failure for that base.
                results_from_pool.append((int(original_arg_pair[1]), False)) # Use the original base for reporting
            
            bases_processed += 1
            if num_bases > 0:
                 current_progress = start_percentage + int((bases_processed / num_bases) * progress_range)
                 if progress_bar_widget:
                     progress_bar_widget['value'] = current_progress
            if root_widget:
                 root_widget.update_idletasks()

    return sorted(results_from_pool, key=lambda x: x[0])

def parse_input_to_int(input_str):
    """
    Parses an input string (number or mathematical expression) using sympy.
    Returns an integer or None on error (and shows a messagebox).
    """
    try:
        number_expr = sympy.sympify(input_str)
        if not number_expr.is_number:
            messagebox.showerror("Input Error", f"Expression '{input_str}' did not evaluate to a number.")
            return None
        number_int = int(number_expr) 
    except Exception as e:
        messagebox.showerror("Input Error", f"Could not parse '{input_str}'. Please insert a valid integer or mathematical expression.\nDetails: {e}")
        return None
    return number_int

def get_input(): 
    """
    Reads a number (or mathematical expression) from the text field
    and attempts to parse it with sympy. Returns an integer or None on error.
    """
    input_string = text_number.get("1.0", tk.END).strip()
    return parse_input_to_int(input_string)

def get_a():
    """
    Reads the base (a) from the corresponding input field
    and returns it as an integer or None on error.
    """
    input_string = entry_a.get().strip()
    try:
        number_int = int(input_string)
    except Exception:
        messagebox.showerror("Input Error", "Please insert only integer values for base 'a'") # Clarified error message
        return None
    return number_int

def check_prime():
    """
    Main function triggered by the 'Check Prime' button.
    Obtains the number n, decides on the testing method, and displays the result.
    """
    input_string = text_number.get("1.0", tk.END).strip()

    if not input_string: 
        return
    if input_string == "0": 
        root.quit()
        return

    start_time_overall = time.time() 

    if check_direct_mersenne_expression(input_string, start_time_overall, root, progress_bar): # MODIFIED: removed result_text_area
        return 

    n_input = parse_input_to_int(input_string)

    if n_input is None: 
        return
    
    progress_bar['value'] = 0 
    root.update_idletasks()

    try:
        n_mpz_val = mpz(n_input) 
    except Exception as e: 
        messagebox.showerror("Input Error", f"Could not convert input to a large number: {e}")
        update_result_text(f"Error: Could not process input {n_input}") # MODIFIED: Use helper
        return

    if n_mpz_val <= 1:
        update_result_text(f"{n_mpz_val} is not prime (by definition).") # MODIFIED: Use helper
        progress_bar['value'] = PROGRESS_BAR_MAX 
        root.update_idletasks()
        return
    if n_mpz_val == 2 or n_mpz_val == 3 or n_mpz_val == 5 or n_mpz_val == 7:
        end_time_overall = time.time()
        update_result_text(f"{n_mpz_val} is prime.\n(Verified in {end_time_overall - start_time_overall:.4f} seconds)") # MODIFIED: Use helper
        progress_bar['value'] = PROGRESS_BAR_MAX 
        root.update_idletasks()
        return

    if check_known_mersenne_primes(n_mpz_val, start_time_overall, root, progress_bar): # MODIFIED: removed result_text_area
        return
    
    progress_bar['value'] = 10 
    root.update_idletasks()

    if n_input < big_num:
        is_sympy_prime = sympy.isprime(n_input) 
        end_time_overall = time.time()
        result_text_sympy = f"{n_input} is {'prime' if is_sympy_prime else 'composite'} (verified by SymPy)."
        update_result_text(f"{result_text_sympy}\n(Tested in {end_time_overall - start_time_overall:.4f} seconds)") # MODIFIED: Use helper & combined text
        progress_bar['value'] = PROGRESS_BAR_MAX
        root.update_idletasks()
        return

    progress_bar['value'] = 20
    root.update_idletasks()

    filter_result = classical_filter(n_mpz_val)
    if filter_result is not None:
        end_time_overall = time.time()
        update_result_text(f"{filter_result}\n(Filtered in {end_time_overall - start_time_overall:.4f} seconds)") # MODIFIED: Use helper
        progress_bar['value'] = PROGRESS_BAR_MAX 
        root.update_idletasks()
        return

    progress_bar['value'] = 40 
    root.update_idletasks()

    base_input_val = get_a() # Renamed to avoid conflict
    if base_input_val is None:
        return
    # It's good practice to ensure the user-provided base isn't 0 or 1, 
    # or negative, as they are not meaningful for these tests.
    if base_input_val <= 1:
        messagebox.showerror("Input Error", "Base 'a' must be greater than 1.")
        return
        
    default_bases = [2, 3, 5, 7, 11, 13] # Standard small prime bases
    # Ensure user base is added and the list contains unique, sorted bases.
    # Filter out bases >= n_mpz_val if n_mpz_val is small, though test handles it.
    bases_to_test = sorted(list(set([base_input_val] + default_bases)))
    # Filter out bases that are not suitable (e.g. >= n or <=1, though euler_test_single_base might handle some)
    bases_to_test = [b for b in bases_to_test if 1 < b < n_mpz_val]
    if not bases_to_test: # If all default bases are >= n or user base was unsuitable
        if 1 < base_input_val < n_mpz_val: # User input was fine, but defaults were too large
            bases_to_test = [base_input_val]
        else: # No suitable bases found, e.g. n is very small (2,3) or user base also unsuitable
             # This case should ideally be caught earlier (n=2,3 are prime). 
             # If n is e.g. 4, bases [2,3] are fine. If n=2, list will be empty.
             # If n_mpz_val is very small (e.g., 2 or 3), this list might be empty.
             # However, such small n should already be handled by direct checks.
             # For robustness, if list is empty, maybe default to a single small prime if n is large enough e.g. 2 if n > 2
            if n_mpz_val > 2 and not any(1 < b_ < n_mpz_val for b_ in default_bases + [base_input_val]):
                 # This means n is small, and all typical bases are too large or invalid
                 # This should have been caught by n_input < big_num or direct n checks
                 update_result_text(f"{n_mpz_val} is too small for the selected bases or direct primality test applies.")
                 progress_bar['value'] = PROGRESS_BAR_MAX
                 return
            elif not bases_to_test: # Still no bases, and n wasn't caught by above logic for very small n
                 # Fallback if n is not extremely small but chosen bases + user base are not < n
                 # This typically means n is prime (2,3,5...) and caught earlier, or composite and caught by filter
                 # Or user entered a base >= n. The check `1 < b < n_mpz_val` is crucial.
                 # If no bases are left, it might imply sympy.isprime should have been used or n is very small.
                 # For now, let's ensure that if n_mpz_val itself is small, it's handled before this point.
                 # If bases_to_test is empty AND n_mpz_val is > threshold for direct checks (e.g. > 7)
                 # AND sympy.isprime wasn't used (n_mpz_val >= big_num), then it is an issue.
                 # The n_input < big_num check should cover most of these.
                 # For now, if no valid bases, report it.
                 update_result_text(f"No suitable bases found for testing {n_mpz_val} (bases must be >1 and <N).")
                 progress_bar['value'] = PROGRESS_BAR_MAX
                 return


    update_result_text("Running Euler-based tests, please wait...") # MODIFIED: Use helper
    root.update_idletasks()

    # Call the new parallel Euler test function
    results = run_euler_tests_parallel(n_mpz_val, bases_to_test, progress_bar, root, 50) # MODIFIED call

    all_passed = True
    results_text_euler = "" 
    if not results: # Should not happen if bases_to_test was not empty
        all_passed = False # Or handle as inconclusive
        results_text_euler = "No bases were tested.\n"
    else:
        for base, passed in results: 
            results_text_euler += f"Base {base}: {'Pass' if passed else 'Fail'}\n"
            if not passed:
                all_passed = False

    if all_passed:
        final_text = "Number is likely prime (passed Euler-based tests for all bases):\n" + results_text_euler
    else:
        final_text = "Number is composite based on Euler-based test(s):\n" + results_text_euler
    
    end_time_overall = time.time() 
    final_text += f"\nTotal time: {end_time_overall - start_time_overall:.4f} seconds."
    update_result_text(final_text) # MODIFIED: Use helper
    progress_bar['value'] = PROGRESS_BAR_MAX 
    root.update_idletasks()

# -------------------  IMPROVED GUI DESIGN  -------------------

def center_window(window, width=700, height=700):
    """
    Helper function to center the window on the screen.
    """
    screen_width = window.winfo_screenwidth()
    screen_height = window.winfo_screenheight()
    x = (screen_width - width) // 2
    y = (screen_height - height) // 2
    window.geometry(f"{width}x{height}+{x}+{y}")

# Create the main window
root = tk.Tk()
root.title("Prime Number Test")
center_window(root, 750, 780)  # Slightly enlarged window for more space

# --- Professional Look: Colors and Fonts ---
BG_COLOR = "#2C3E50"         # Dark blue
INPUT_BG_COLOR = "#34495E"   # Slightly lighter dark blue
TEXT_COLOR = "#ECF0F1"       # Very light gray / almost white
TITLE_TEXT_COLOR = "#FFFFFF"   # White
BUTTON_BG_COLOR = "#E67E22"   # Orange
BUTTON_FG_COLOR = "#FFFFFF"   # White
BUTTON_ACTIVE_BG_COLOR = "#F39C12" # Lighter orange
BORDER_COLOR = "#233140"      # Darker shade of blue for borders
SCROLLBAR_BG_COLOR = "#34495E"

root.configure(bg=BG_COLOR)

# Fonts
try:
    # Attempt to use more modern fonts if available
    TITLE_FONT = ("Segoe UI", 16, "bold")
    LABELFRAME_TITLE_FONT = ("Segoe UI", 13, "bold") # New font for LabelFrame titles
    LABEL_FONT = ("Segoe UI", 12)
    INSTRUCTION_TEXT_FONT = ("Segoe UI", 10)      # Smaller font for instruction text
    BUTTON_FONT = ("Segoe UI", 13, "bold")
    RESULT_FONT = ("Segoe UI", 12)
except tk.TclError:
    # Fallback to Helvetica if preferred fonts are not available
    TITLE_FONT = ("Helvetica", 14, "bold") 
    LABELFRAME_TITLE_FONT = ("Helvetica", 12, "bold") # New font for LabelFrame titles
    LABEL_FONT = ("Helvetica", 11)         
    INSTRUCTION_TEXT_FONT = ("Helvetica", 9)       # Smaller font for instruction text
    BUTTON_FONT = ("Helvetica", 12, "bold")
    RESULT_FONT = ("Helvetica", 11)        

# Label frame for instructions
instructions_frame = tk.LabelFrame(
    root, text="Instructions", bg=BG_COLOR, fg=TITLE_TEXT_COLOR,
    font=LABELFRAME_TITLE_FONT, bd=2, relief="solid", borderwidth=1, highlightbackground=BORDER_COLOR # Used new font
)
instructions_frame.pack(fill="x", padx=20, pady=(15,5)) # Slightly adjusted padding

instruction_text = (
    "This program uses sympy.isprime for numbers less than 10^20.\n"
    "For larger numbers, it first applies a classical filter (trial division by small primes\n"
    "and numbers of the form 6kÂ±1). If the number passes this filter, an Euler-based test (a^((N-1)/2) % N == Â±1) \n"
    "is then used with multiple bases.\n\n"
    "A 'likely prime' result from the Euler-based test indicates a high probability\n"
    "that the number is prime.\n\n"
    "Pseudoprimes are non-genuine primes. For enhanced results, several bases (e.g., 2, 3, 5, 7, 11, 13)\n"
    "will be tested concurrently using multiprocessing.\n\n"
    "Note: You can also input mathematical expressions. Example: 2**13-1, 15!-1\n"    
)

instructions_label = tk.Label(
    instructions_frame, text=instruction_text, bg=BG_COLOR, fg=TEXT_COLOR,
    font=INSTRUCTION_TEXT_FONT, justify="left", wraplength=680 # Used new smaller font
)
instructions_label.pack(padx=15, pady=(5,10)) # Slightly adjusted padding

# Frame for input fields
input_frame = tk.Frame(root, bg=BG_COLOR)
input_frame.pack(padx=20, pady=10, fill="x")

# Input Number + Scrollbar
tk.Label(
    input_frame, text="Enter the number (or expression):", bg=BG_COLOR, fg=TEXT_COLOR,
    font=LABEL_FONT
).grid(row=0, column=0, sticky="w", padx=5, pady=(5,0))

# Frame for the text area and scrollbar
text_area_frame = tk.Frame(input_frame, bg=INPUT_BG_COLOR, relief="solid", borderwidth=1, highlightthickness=1, highlightbackground=BORDER_COLOR)
text_area_frame.grid(row=1, column=0, columnspan=2, padx=5, pady=(0,10), sticky="ew")

text_number = tk.Text(
    text_area_frame, height=3, width=38, bg=INPUT_BG_COLOR, fg=TITLE_TEXT_COLOR,
    insertbackground=TITLE_TEXT_COLOR, font=LABEL_FONT, relief="flat", borderwidth=0, highlightthickness=0
)
text_number.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

scrollbar_y = tk.Scrollbar(text_area_frame, command=text_number.yview, relief="flat", bg=SCROLLBAR_BG_COLOR, troughcolor=INPUT_BG_COLOR, activerelief="flat")
scrollbar_y.pack(side=tk.RIGHT, fill=tk.Y)

text_number.config(yscrollcommand=scrollbar_y.set)

# Input Base 'a'
tk.Label(
    input_frame, text="Test with base 'a' (used in Euler test, defaults exist):", bg=BG_COLOR, fg=TEXT_COLOR,
    font=LABEL_FONT
).grid(row=2, column=0, sticky="w", padx=5, pady=(5,0)) # Align left

entry_a = tk.Entry(
    input_frame, width=15, bg=INPUT_BG_COLOR, fg=TITLE_TEXT_COLOR, # A bit wider
    insertbackground=TITLE_TEXT_COLOR, font=LABEL_FONT, relief="solid", borderwidth=1, highlightthickness=1, highlightbackground=BORDER_COLOR
)
entry_a.insert(0, "2")
entry_a.grid(row=3, column=0, padx=5, pady=(0,10), sticky="w")

# Configure grid column weights for input_frame to make text_number and entry_a expandable if needed
input_frame.grid_columnconfigure(0, weight=1)


# Frame for the "Check Prime" button
button_frame = tk.Frame(root, bg=BG_COLOR)
button_frame.pack(pady=15)

check_button = tk.Button(
    button_frame, text="Check Primality", command=check_prime,
    bg=BUTTON_BG_COLOR, fg=BUTTON_FG_COLOR, font=BUTTON_FONT, 
    relief="raised", bd=2, padx=20, pady=5, # Larger button
    activebackground=BUTTON_ACTIVE_BG_COLOR, activeforeground=BUTTON_FG_COLOR
)
check_button.pack()

# Frame for the Progress Bar
progress_frame = tk.Frame(root, bg=BG_COLOR)
progress_frame.pack(fill="x", padx=20, pady=(5, 5)) # Smaller padding around the progress bar

progress_bar = ttk.Progressbar(
    progress_frame, 
    orient="horizontal", 
    length=300, 
    mode='determinate'
    # maximum will be set later if needed, default is 100
)
progress_bar.pack(fill="x", expand=True, padx=5, pady=5)

# Label frame for results
result_frame = tk.LabelFrame(
    root, text="Result", bg=BG_COLOR, fg=TITLE_TEXT_COLOR,
    font=LABELFRAME_TITLE_FONT, bd=2, relief="solid", borderwidth=1, highlightbackground=BORDER_COLOR # Use LabelFrame Title Font
)
result_frame.pack(fill="both", expand=True, padx=20, pady=(10,20)) # Larger padding

# Make the result_frame's content area (where text area will go) expand
result_frame.grid_rowconfigure(0, weight=1)
result_frame.grid_columnconfigure(0, weight=1)

# Create a Text widget for results with a Scrollbar
result_text_area = tk.Text(
    result_frame, 
    wrap=tk.WORD, # Wrap text at word boundaries
    bg=BG_COLOR, 
    fg=TEXT_COLOR, 
    font=RESULT_FONT,
    relief="flat", # Flat relief to blend with the frame
    borderwidth=0,
    highlightthickness=0,
    padx=10, # Padding inside the text area
    pady=10
)
result_text_area.grid(row=0, column=0, sticky="nsew") # Use grid to place it

result_scrollbar = ttk.Scrollbar( # Use ttk.Scrollbar for better styling
    result_frame, 
    orient="vertical", 
    command=result_text_area.yview
)
result_scrollbar.grid(row=0, column=1, sticky="ns") # Place scrollbar next to text area

result_text_area.config(yscrollcommand=result_scrollbar.set, state="disabled") # Link scrollbar and set initial state to disabled

# Helper function to update the result_text_area
def update_result_text(new_text):
    result_text_area.config(state="normal")
    result_text_area.delete("1.0", tk.END)
    result_text_area.insert(tk.END, new_text)
    result_text_area.config(state="disabled")

if __name__ == '__main__':
    root.mainloop()
# -------------------  END OF PRIME NUMBERS GUI  -------------------
